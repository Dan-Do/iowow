diff --git a/src/kv/iwkv.c b/src/kv/iwkv.c
index 61b3ae6..6db0968 100644
--- a/src/kv/iwkv.c
+++ b/src/kv/iwkv.c
@@ -1334,12 +1334,13 @@ static WUR iwrc _sblk_at2(IWLCTX *lx, off_t addr, sblk_flags_t flgs, SBLK *sblk)
   uint8_t *mm;
   uint32_t lv;
   sblk_flags_t flags = lx->sbflags | flgs;
-  IWFS_FSM *fsm = &lx->db->iwkv->fsm;
+  IWDB db = lx->db;
+  IWFS_FSM *fsm = &db->iwkv->fsm;
   sblk->kvblk = 0;
-  sblk->db = lx->db;
+  sblk->db = db;
   rc = fsm->acquire_mmap(fsm, 0, &mm, 0);
   RCRET(rc);
-  if (IW_UNLIKELY(addr == lx->db->addr)) {
+  if (IW_UNLIKELY(addr == db->addr)) {
     uint8_t *rp = mm + addr + DOFF_N0_U4;
     // [magic:u4,dbflg:u1,dbid:u4,next_db_blk:u4,p0:u4,n[24]:u4,c[24]:u4,meta_blk:u4,meta_blkn:u4]:217
     sblk->addr = addr;
@@ -1405,8 +1406,11 @@ static WUR iwrc _sblk_at2(IWLCTX *lx, off_t addr, sblk_flags_t flgs, SBLK *sblk)
     }
     rp = mm + addr + SOFF_LK;
     memcpy(sblk->lk, rp, (size_t) sblk->lkl);
+    if ((db->dbflg & IWDB_IDX_DUPKV) && SBLK_LKLEN - sblk->lkl >= sizeof(lx->idupv)) {
+      memcpy(sblk->lk + sblk->lkl, rp + sblk->lkl, sizeof(lx->idupv));
+    }
   } else { // Database tail
-    uint8_t *rp = mm + lx->db->addr + DOFF_P0_U4;
+    uint8_t *rp = mm + db->addr + DOFF_P0_U4;
     sblk->addr = 0;
     sblk->flags = SBLK_DB | flags;
     sblk->lvl = 0;
@@ -1416,7 +1420,7 @@ static WUR iwrc _sblk_at2(IWLCTX *lx, off_t addr, sblk_flags_t flgs, SBLK *sblk)
     memset(sblk->pi, 0, sizeof(sblk->pi));
     IW_READLV(rp, lv, sblk->p0);
     if (!sblk->p0) {
-      sblk->p0 = ADDR2BLK(lx->db->addr);
+      sblk->p0 = ADDR2BLK(db->addr);
     }
   }
 
@@ -1486,6 +1490,10 @@ static WUR iwrc _sblk_sync_mm(IWLCTX *lx, SBLK *sblk, uint8_t *mm) {
       }
       wp = mm + sblk->addr + SOFF_LK;
       memcpy(wp, sblk->lk, (size_t) sblk->lkl);
+      wp += sblk->lkl;
+      if ((lx->db->dbflg & IWDB_IDX_DUPKV) && SBLK_LKLEN - sblk->lkl >= sizeof(lx->idupv)) {
+        memcpy(wp, sblk->lk + sblk->lkl, sizeof(lx->idupv));
+      }
       if (dlsnr) {
         rc = dlsnr->onwrite(dlsnr, sblk->addr, mm + sblk->addr, SOFF_END, 0);
         RCRET(rc);
@@ -1662,21 +1670,14 @@ static WUR iwrc _sblk_addkv2(SBLK *sblk, int8_t idx,
   ++sblk->pnum;
   sblk->flags |= SBLK_DURTY;
   if (idx == 0) { // the lowest key inserted
-    size_t lksz = key->size;
-    if (dbflg & IWDB_IDX_DUPKV) {
-      lksz += sizeof(lx->idupv);
-    }
-    if ((dbflg & IWDB_IDX_DUPKV) && lksz <= SBLK_LKLEN) {
+    sblk->lkl = MIN(SBLK_LKLEN, key->size);
+    memcpy(sblk->lk, key->data, sblk->lkl);
+    if ((dbflg & IWDB_IDX_DUPKV) && (SBLK_LKLEN - sblk->lkl) >= sizeof(lx->idupv)) {
       int64_t llv = lx->idupv;
       llv = IW_HTOILL(llv);
-      sblk->lkl = lksz;
-      memcpy(sblk->lk, key->data, key->size);
-      memcpy(sblk->lk + key->size, &llv, sizeof(int64_t));
-    } else {
-      sblk->lkl = MIN(SBLK_LKLEN, key->size);
-      memcpy(sblk->lk, key->data, sblk->lkl);
+      memcpy(sblk->lk + sblk->lkl, &llv, sizeof(llv));
     }
-    if (lksz <= SBLK_LKLEN) {
+    if (key->size <= SBLK_LKLEN) {
       sblk->flags |= SBLK_FULL_LKEY;
     } else {
       sblk->flags &= ~SBLK_FULL_LKEY;
@@ -1773,8 +1774,7 @@ static WUR iwrc _sblk_addkv(SBLK *sblk, IWLCTX *lx, bool skip_cursors) {
 }
 
 static WUR iwrc _sblk_updatekv(SBLK *sblk, int8_t idx,
-                               const IWKV_val *key, const IWKV_val *val,
-                               iwkv_opflags opflags) {
+                               const IWKV_val *key, const IWKV_val *val) {
   assert(sblk && sblk->kvblk && idx >= 0 && idx < sblk->pnum);
   IWDB db = sblk->db;
   KVBLK *kvblk = sblk->kvblk;
@@ -1810,6 +1810,7 @@ static WUR iwrc _sblk_updatekv(SBLK *sblk, int8_t idx,
 static WUR iwrc _sblk_rmkv(SBLK *sblk, uint8_t idx) {
   assert(sblk && sblk->kvblk);
   IWDB db = sblk->db;
+  iwdb_flags_t dbflg = db->dbflg;
   KVBLK *kvblk = sblk->kvblk;
   IWFS_FSM *fsm = &sblk->db->iwkv->fsm;
   assert(kvblk && idx < sblk->pnum && sblk->pi[idx] < KVBLK_IDXNUM);
@@ -1830,14 +1831,26 @@ static WUR iwrc _sblk_rmkv(SBLK *sblk, uint8_t idx) {
     uint8_t *mm;
     rc = fsm->acquire_mmap(fsm, 0, &mm, 0);
     RCRET(rc);
-    // Replace key with the next one or reset
+    // Replace the lowest key with the next one or reset
     if (sblk->pnum > 0) {
       uint8_t *kbuf;
-      uint32_t klen;
+      uint32_t klen, vlen;
       rc = _kvblk_peek_key(sblk->kvblk, sblk->pi[idx], mm, &kbuf, &klen);
-      RCRET(rc);
+      RCGO(rc, lkfinish);
       sblk->lkl = MIN(SBLK_LKLEN, klen);
       memcpy(sblk->lk, kbuf, sblk->lkl);
+      if ((dbflg & IWDB_IDX_DUPKV) && (SBLK_LKLEN - sblk->lkl) >= sizeof(int64_t)) {
+        int64_t llv;
+        _kvblk_peek_val(sblk->kvblk, sblk->pi[idx], mm, &kbuf, &vlen);
+        if (vlen > IW_VNUMBUFSZ) {
+          iwlog_ecode_error3(IWKV_ERROR_CORRUPTED);
+          rc = IWKV_ERROR_CORRUPTED;
+          goto lkfinish;
+        }
+        IW_READVNUMBUF64_2(kbuf, llv);
+        llv = IW_HTOILL(llv);
+        memcpy(sblk->lk + sblk->lkl, &llv, sizeof(llv));
+      }
       if (klen <= SBLK_LKLEN) {
         sblk->flags |= SBLK_FULL_LKEY;
       } else {
@@ -1850,27 +1863,81 @@ static WUR iwrc _sblk_rmkv(SBLK *sblk, uint8_t idx) {
       sblk->lkl = 0;
       sblk->flags |= SBLK_CACHE_REMOVE;
     }
+lkfinish:
     fsm->release_mmap(fsm);
   }
-  // Update active cursors
-  pthread_spin_lock(&db->cursors_slk);
-  for (IWKV_cursor cur = db->cursors; cur; cur = cur->next) {
-    if (cur->cn && cur->cn->addr == sblk->addr) {
-      memcpy(cur->cn, sblk, sizeof(*cur->cn));
-      cur->cn->kvblk = 0;
-      cur->cn->flags &= SBLK_PERSISTENT_FLAGS;
-      if (cur->cnpos > idx) {
-        cur->cnpos--;
+  if (!rc) {
+    // Update active cursors
+    pthread_spin_lock(&db->cursors_slk);
+    for (IWKV_cursor cur = db->cursors; cur; cur = cur->next) {
+      if (cur->cn && cur->cn->addr == sblk->addr) {
+        memcpy(cur->cn, sblk, sizeof(*cur->cn));
+        cur->cn->kvblk = 0;
+        cur->cn->flags &= SBLK_PERSISTENT_FLAGS;
+        if (cur->cnpos > idx) {
+          cur->cnpos--;
+        }
       }
     }
+    pthread_spin_unlock(&db->cursors_slk);
   }
-  pthread_spin_unlock(&db->cursors_slk);
   return rc;
 }
 
 //--------------------------  IWLCTX
+static WUR iwrc _lx_sblk_cmp_key(IWLCTX *lx, SBLK *sblk, int *resp) {
+  iwdb_flags_t dbflg = sblk->db->dbflg;
+  bool dupkv = (dbflg & IWDB_IDX_DUPKV);
+  const IWKV_val *key = lx->key;
+  int64_t dupv;
+  if (IW_UNLIKELY(sblk->pnum < 1 || (sblk->flags & SBLK_DB))) { // empty block
+    *resp = 0;
+    iwlog_ecode_error3(IWKV_ERROR_CORRUPTED);
+    return IWKV_ERROR_CORRUPTED;
+  }
 
-IW_INLINE WUR iwrc _lx_sblk_cmp_key(IWLCTX *lx, SBLK *sblk, int *resp) {
+  if ((sblk->flags & SBLK_FULL_LKEY) || key->size < sblk->lkl) {
+    *resp = _cmp_key(dbflg, sblk->lk, sblk->lkl, key->data, key->size);
+    if (dupkv && *resp == 0) {
+      if (SBLK_LKLEN - sblk->lkl >= sizeof(lx->idupv)) {
+        // memcpy(&dupv,)
+      }
+    }
+  } else {
+    *resp = _cmp_key2(dbflg, sblk->lk, sblk->lkl, key->data, key->size);
+    if (*resp == 0) {
+      uint32_t kl;
+      uint8_t *mm, *k;
+      IWFS_FSM *fsm = &lx->db->iwkv->fsm;
+      iwrc rc = fsm->acquire_mmap(fsm, 0, &mm, 0);
+      if (rc) {
+        *resp = 0;
+        return rc;
+      }
+      if (!sblk->kvblk) {
+        rc = _sblk_loadkvblk_mm(lx, sblk, mm);
+        if (rc) {
+          *resp = 0;
+          fsm->release_mmap(fsm);
+          return rc;
+        }
+      }
+      rc = _kvblk_peek_key(sblk->kvblk, sblk->pi[0], mm, &k, &kl);
+      if (rc) {
+        *resp = 0;
+        fsm->release_mmap(fsm);
+        return rc;
+      }
+      *resp = _cmp_key(dbflg, k, kl, key->data, key->size);
+      fsm->release_mmap(fsm);
+    }
+  }
+
+  return 0;
+}
+
+
+IW_INLINE WUR iwrc _lx_sblk_cmp_key_old(IWLCTX *lx, SBLK *sblk, int *resp) {
   int res = 0;
   iwrc rc = 0;
   iwdb_flags_t dbflg = sblk->db->dbflg;
@@ -2291,7 +2358,7 @@ static WUR iwrc _lx_addkv(IWLCTX *lx) {
     } else {
       fsm->release_mmap(fsm);
     }
-    return _sblk_updatekv(sblk, idx, lx->key, val, lx->opflags);
+    return _sblk_updatekv(sblk, idx, lx->key, val);
   } else {
     fsm->release_mmap(fsm);
     if (sblk->pnum > KVBLK_IDXNUM - 1) {
@@ -2470,37 +2537,39 @@ static WUR iwrc _dbcache_cmp_nodes(const void *v1, const void *v2, void *op, int
   iwrc rc = 0;
   uint8_t *mm = 0;
   IWLCTX *lx = op;
-  IWFS_FSM *fsm = &lx->db->iwkv->fsm;
-  const DBCNODE *c1 = v1, *c2 = v2;
-  uint8_t *k1 = (uint8_t *) c1->lk, *k2 = (uint8_t *) c2->lk;
-  uint32_t kl1 = c1->lkl, kl2 = c2->lkl;
+  IWDB db = lx->db;
+  IWFS_FSM *fsm = &db->iwkv->fsm;
+  iwdb_flags_t dbflg = db->dbflg;
+  bool dupkv = (dbflg & IWDB_IDX_DUPKV);
 
-  // todo:
-  // bool dupkv = (dbflg & IWDB_IDX_DUPKV);
+  const DBCNODE *cn1 = v1, *cn2 = v2;
+  uint8_t *k1 = (uint8_t *) cn1->lk, *k2 = (uint8_t *) cn2->lk;
+  uint32_t kl1 = cn1->lkl, kl2 = cn2->lkl;
 
-  if (!kl1 && c1->fullkey) {
-    kl1 = c1->sblkn;
+  if (!kl1 && cn1->fullkey) {
+    kl1 = cn1->sblkn;
   }
-  if (!kl2 && c2->fullkey) {
-    kl2 = c2->sblkn;
+  if (!kl2 && cn2->fullkey) {
+    kl2 = cn2->sblkn;
   }
-  *res = _cmp_key2(lx->db->dbflg, k1, kl1, k2, kl2);
-  if (*res == 0 && (!c1->fullkey || !c2->fullkey)) {
+
+  *res = _cmp_key2(dbflg, k1, kl1, k2, kl2);
+  if (*res == 0 && (!cn1->fullkey || !cn2->fullkey)) {
     rc = fsm->acquire_mmap(fsm, 0, &mm, 0);
     RCRET(rc);
-    if (!c1->fullkey) {
-      rc = _kvblk_at_mm(lx, BLK2ADDR(c1->kblkn), mm, 0, &kb);
+    if (!cn1->fullkey) {
+      rc = _kvblk_at_mm(lx, BLK2ADDR(cn1->kblkn), mm, 0, &kb);
       RCGO(rc, finish);
-      rc = _kvblk_peek_key(kb, c1->k0idx, mm, &k1, &kl1);
+      rc = _kvblk_peek_key(kb, cn1->k0idx, mm, &k1, &kl1);
       RCGO(rc, finish);
     }
-    if (!c2->fullkey) {
-      rc = _kvblk_at_mm(lx, BLK2ADDR(c2->kblkn), mm, 0, &kb);
+    if (!cn2->fullkey) {
+      rc = _kvblk_at_mm(lx, BLK2ADDR(cn2->kblkn), mm, 0, &kb);
       RCGO(rc, finish);
-      rc = _kvblk_peek_key(kb, c2->k0idx, mm, &k2, &kl2);
+      rc = _kvblk_peek_key(kb, cn2->k0idx, mm, &k2, &kl2);
       RCGO(rc, finish);
     }
-    *res = _cmp_key(lx->db->dbflg, k1, kl1, k2, kl2);
+    *res = _cmp_key(dbflg, k1, kl1, k2, kl2);
   }
 
 finish:
@@ -2535,7 +2604,16 @@ static WUR iwrc _dbcache_fill_lw(IWLCTX *lx) {
     return 0;
   }
   c->lvl = _dbcache_lvl(sdb->lvl);
-  c->nsize = (lx->db->dbflg & IWDB_VNUM64_KEYS) ? DBCNODE_VNUM_SZ : DBCNODE_STR_SZ;
+
+  if (db->dbflg & IWDB_VNUM64_KEYS) {
+    c->nsize = DBCNODE_VNUM_SZ;
+    if (db->dbflg & IWDB_IDX_DUPKV) {
+      c->nsize += sizeof(lx->idupv);
+    }
+  } else {
+    c->nsize = DBCNODE_STR_SZ;
+  }
+
   c->asize = c->nsize * ((1U << DBCACHE_LEVELS) + DBCACHE_ALLOC_STEP);
   size_t nsize = c->nsize;
   c->nodes = malloc(c->asize);
@@ -2641,7 +2719,7 @@ static WUR iwrc _dbcache_put_lw(IWLCTX *lx, SBLK *sblk) {
   uint8_t dbcbuf[1024];
   DBCNODE *n = (DBCNODE *) dbcbuf;
   DBCACHE *cache = &db->cache;
-  register size_t nsize = cache->nsize;
+  size_t nsize = cache->nsize;
 
   sblk->flags &= ~SBLK_CACHE_PUT;
   cache->atime = lx->ts;
@@ -3864,7 +3942,7 @@ iwrc iwkv_cursor_set(IWKV_cursor cur, IWKV_val *val, iwkv_opflags opflags) {
   IWDB db = lx->db;
   IWKV iwkv = db->iwkv;
   API_DB_WLOCK(db, rci);
-  rc = _sblk_updatekv(cur->cn, cur->cnpos, 0, val, opflags);
+  rc = _sblk_updatekv(cur->cn, cur->cnpos, 0, val);
   if (IWKV_IS_INTERNAL_RC(rc)) {
     irc = rc;
     rc = 0;
diff --git a/src/kv/iwkv.h b/src/kv/iwkv.h
index f3f741f..d28e19c 100644
--- a/src/kv/iwkv.h
+++ b/src/kv/iwkv.h
@@ -94,6 +94,7 @@ typedef uint8_t iwdb_flags_t;
 #define IWDB_REALNUM_KEYS     ((iwdb_flags_t) 0x10U)
 /** Variable-length number keys */
 #define IWDB_VNUM64_KEYS      ((iwdb_flags_t) 0x20U)
+
 /** Compound dup index key/value mode
  *  todo: description
  */
@@ -145,8 +146,8 @@ typedef struct IWKV_OPTS {
  * @brief Data container for key/value.
  */
 typedef struct IWKV_val {
-  void  *data;            /**< Data buffer */
-  size_t  size;           /**< Data buffer size */
+  void *data;            /**< Data buffer */
+  size_t size;           /**< Data buffer size */
 } IWKV_val;
 
 /**
diff --git a/src/kv/iwkv_internal.h b/src/kv/iwkv_internal.h
index 478fdf8..d8ef8b4 100644
--- a/src/kv/iwkv_internal.h
+++ b/src/kv/iwkv_internal.h
@@ -147,8 +147,6 @@ typedef struct KVBLK {
 #define SBLK_PERSISTENT_FLAGS (SBLK_FULL_LKEY)
 #define SBLK_CACHE_FLAGS (SBLK_CACHE_UPDATE | SBLK_CACHE_PUT | SBLK_CACHE_REMOVE)
 
-#define IWDB_DUP_FLAGS (IWDB_DUP_UINT32_VALS | IWDB_DUP_UINT64_VALS)
-
 // Number of top levels to cache (~ (1<<DBCACHE_LEVELS) cached elements)
 #define DBCACHE_LEVELS 10U
 
